<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>c语言指针用法</title>
    <link href="/2021/06/09/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E7%94%A8%E6%B3%95/"/>
    <url>/2021/06/09/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><em>这里指针的内容根据c Primer Plus上整理出来的，省略了书上部分内容，只记录了容易混淆的一些内容。</em></p><span id="more"></span><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>数据存储在内存中，他们都有特定的存放位置，而内存地址便是像门牌一样，用来表示数据的位置，想要找到这些数据，就要通过地址来进行查找。先定义一个整型变量: int num = 10，这个num的变量存储的值是10。而指针变量，和普通的变量不同，其存储的值为地址。</p><h2 id="声明指针"><a href="#声明指针" class="headerlink" title="声明指针"></a>声明指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> *num;  <span class="hljs-comment">// num是指向int类型数据的指针变量</span><br></code></pre></td></tr></table></figure><p>指针变量的声明和普通的变量声明类似，星号*用于表明声明的变量是一个指针，int表明指针所指向的数据的类型。</p><h2 id="操作指针"><a href="#操作指针" class="headerlink" title="操作指针"></a>操作指针</h2><h3 id="指针赋值"><a href="#指针赋值" class="headerlink" title="指针赋值"></a>指针赋值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> ca = <span class="hljs-number">20</span>;<br>num = &amp;ca;  <span class="hljs-comment">// 必须是将地址赋值给指针变量</span><br></code></pre></td></tr></table></figure><p>上面的num = &amp;ca，就是使用&amp;地址运算符，将ca的地址赋值给num，赋值后，num便指向ca。</p><h3 id="获取指针的值"><a href="#获取指针的值" class="headerlink" title="获取指针的值"></a>获取指针的值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p &quot;</span>, num);  <span class="hljs-comment">// 输出num的值(也就是其指向的地址)。输出结果: 000000000061FE14</span><br></code></pre></td></tr></table></figure><p>这里获取的是num的值，num是一个指针变量，其存储的便是地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *num);<br></code></pre></td></tr></table></figure><p>通过*解引用运算符可以获得指针变量所指向的地址中存储的数据。注意: 在定义指针变量和在定义指针变量后，星号 * 的含义和作用是不一样的。</p><p><em>在定义时，星号表示声明的变量是一个指针</em></p><p><em>在定义完之后使用，星号表示获取存储在地址上的数据:</em></p><h2 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-keyword">int</span> *pti = arr;  <span class="hljs-comment">// pti为指向int类型数据的指针</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %d&quot;</span>, pti, *pti);  <span class="hljs-comment">// 输出结果: 000000000061FE0C  1</span><br></code></pre></td></tr></table></figure><p>从上面的例子可以看出，数组名就是该数组首元素的地址。数组中的数据在内存中的存放是连续的，也就是说通过对指针变量的加减，可以实现指针指向数组中的不同元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 注意，*运算符优先级高于+，如果写成这种方式:*pti + 1，这表示先获取pti所指向的值然后再加1</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s&quot;</span>, *(pti + <span class="hljs-number">1</span>), (pti + <span class="hljs-number">1</span>));  <span class="hljs-comment">// 输出结果: 2 000000000061FE10</span><br></code></pre></td></tr></table></figure><p>将pti指针+1后，输出它所指向的地址和地址所存储的值，发现pti这时候指向的是数组中的2这个元素，但是”000000000061FE0C”和”000000000061FE10”这两个地址之间并不是只加了1，两者相减发现是相差了4，这表示指针加1不是直接加1，而是加一次指针所指向的类型的大小(int 类型占用4个字节)，指针加1之后就是下一个元素的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> *t1 = arr;  <span class="hljs-comment">// 将数组第一个元素的地址赋值给t1</span><br><span class="hljs-keyword">int</span> *t2 = &amp;arr[<span class="hljs-number">3</span>];  <span class="hljs-comment">// 将数组第四个元素赋值给t2</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;地址相减的差值为%td &quot;</span>, t2 - t1);  <span class="hljs-comment">// 输出结果:地址相减的差值为3</span><br></code></pre></td></tr></table></figure><p>对地址的相减，会得出两个地址之间相差多少个元素。指针的相加相减，都是以一个元素的大小为单位的，而不是直接对地址进行整数的加减。</p><h2 id="多维数组和指针"><a href="#多维数组和指针" class="headerlink" title="多维数组和指针"></a>多维数组和指针</h2><h3 id="指向多维数组的指针"><a href="#指向多维数组的指针" class="headerlink" title="指向多维数组的指针"></a>指向多维数组的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> arr2[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;, &#123;<span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;&#125;;<br><span class="hljs-keyword">int</span> (*pz)[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 指向一个内含两个int类型值的数组</span><br>pz = arr;<br><span class="hljs-comment">// 由于[]的优先级高于*，所以会先和pzx进行结合，那么pzx就成为了一个内含两个元素的数组，*</span><br><span class="hljs-comment">// 则表示pax数组内含两个指针</span><br><span class="hljs-keyword">int</span> *pzx[<span class="hljs-number">2</span>];  <span class="hljs-comment">// pzx是一个内含两个指针元素的数组，每个元素都指向int的指针</span><br></code></pre></td></tr></table></figure><p>将arr首元素的地址赋值给pz，pz就指向一个内含两个int类型元素的数组，pz的地址就是{2, 3}这个数组的首元素的地址，pz和arr2[0]、arr2[0][0]的地址是相同的。</p><p>因为pz指向的对象是一个包含两个int类型元素的数组，arr[0]指向一个int类型的元素，两者地址虽然相同，但是在指向这一方面是不一样的。所以，如果想通过pz获取数组中2这个元素，需要解引用两次:**pz，第一次解引用，*pz代表着获取这个数组的首元素的地址(也就是2的地址)，第二次解引用才能获取pz所指向的地址所存储的值。</p><h3 id="指针赋值的需要注意的地方"><a href="#指针赋值的需要注意的地方" class="headerlink" title="指针赋值的需要注意的地方"></a>指针赋值的需要注意的地方</h3><ol><li>定义的指针为什么类型，就只能赋什么类型的值。</li><li>如果定义了一个指向指针的指针(例如: int **pu;)，那么就只能将其他指针赋值给pu，而*pu获取的值就是指针。</li><li>不能直接使用指针来创建数组，因为指针只能存储地址。</li></ol><h2 id="字符串、字符串数组与指针的联系"><a href="#字符串、字符串数组与指针的联系" class="headerlink" title="字符串、字符串数组与指针的联系"></a>字符串、字符串数组与指针的联系</h2><h3 id="声明字符串"><a href="#声明字符串" class="headerlink" title="声明字符串"></a>声明字符串</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 方式1</span><br><span class="hljs-keyword">char</span> str2[] = <span class="hljs-string">&quot;testing2&quot;</span>;  <span class="hljs-comment">// 字符串数组</span><br><span class="hljs-comment">// 方式2</span><br><span class="hljs-keyword">char</span> *str3 = <span class="hljs-string">&quot;testing3&quot;</span>;  <span class="hljs-comment">// 使用指针表示法创建字符串</span><br><br></code></pre></td></tr></table></figure><p>这两种方式都可以用来创建字符串，str2和str3的值都是字符串的地址。</p><h3 id="数组形式和指针形式创建的字符串的不同"><a href="#数组形式和指针形式创建的字符串的不同" class="headerlink" title="数组形式和指针形式创建的字符串的不同"></a>数组形式和指针形式创建的字符串的不同</h3><p>数组形式创建的字符串，字符串存储在静态存储取中，程序运行后会将字符串拷贝到数组，也就是有两份相同的字符串，一份在静态内存中，一份存储在数组中(也就是str2的地址所存储的值便是这个字符串)。str2是地址常量，不能对其进行修改(例如str2++这样对str2本身进行修改是不行的)。而指针形式创建的字符串，指针变量存储的值是字符串的地址，可以对指针变量进行修改，这样不会影响到字符串。数组形式创建的字符串可以进行值的修改(例如:str2[1]  = ‘x’)，不能对指针形式创建的字符串进行修改(例如: str3[3] = ‘x’ 这样是不允许的)。</p><h2 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h2><h3 id="一维数组和函数"><a href="#一维数组和函数" class="headerlink" title="一维数组和函数"></a>一维数组和函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ar, <span class="hljs-keyword">int</span>)</span></span>;  <span class="hljs-comment">// 函数原型</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    test(arr, <span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ar, <span class="hljs-keyword">int</span> size)</span>  <span class="hljs-comment">// 函数定义头</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size;i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, *(ar++));  <span class="hljs-comment">//@2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面调用test函数时，将数组arr作为参数传递，传递的是arr数组的地址(数组名是该数组首元素的地址)。在test函数中，ar是作为一个指针。函数原型和函数定义头中，使用的是int *ar，但是也可以将其替换称int ar[]。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将int \*ar换成int ar[]</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>这样也是可以的，都表示ar是一个指向int的指针，但是int ar[]这种形式可以明确的表示ar是一个数组。</p><h3 id="多维数组和函数"><a href="#多维数组和函数" class="headerlink" title="多维数组和函数"></a>多维数组和函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*ar)[<span class="hljs-number">3</span>])</span></span>;<br>main(<span class="hljs-keyword">void</span>)<br>&#123;<br><span class="hljs-keyword">int</span> tp[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = &#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;&#125;;<br>test2(tp);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*ar)[<span class="hljs-number">3</span>])</span></span><br><span class="hljs-function"></span>&#123;<br>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里的int (*ar)[3]代表着ar是一个指向数组的指针，而数组中包含有3个元素，这样定义函数原型就可以将一个二维数组作为参数传递给test2函数。当然了，也可以直接使用int ar[][3]放在函数原型和函数定义头中，第一个括号为空代表着ar是一个指针，即使在第一个括号中写具体的大小，编译器也会将忽略该值。</p>]]></content>
    
    
    <categories>
      
      <category>c</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pointer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>狄克斯特拉算法-算法图解第七章</title>
    <link href="/2020/06/02/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    <url>/2020/06/02/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%B8%83%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="何为狄克斯特拉算法"><a href="#何为狄克斯特拉算法" class="headerlink" title="何为狄克斯特拉算法"></a>何为狄克斯特拉算法</h2><p>1.狄克斯特拉算法用于权重图（每一条边都有其相对应的数字），算法可以找出图中权重相加最小的路径。</p><p>2.和广度优先搜索不同的是，狄克斯特拉算法找的是总权重最小的路径，而广度优先搜索则是应用于非加权图，找的是段数最少的路径。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p><img src="/img/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%B8%83%E7%AB%A0/Snipaste_2020-06-02_22-45-56.png"></p><p>以这张图片为例，起点为start，终点为fin。那么节点start的邻居就有A、B，节点A的邻居有fin，节点B的邻居有fin，节点fin则没有邻居。</p><p>这个算法一共需要三个表，一个记录所有的节点和其邻居，一个记录从起点到该节点所需的花销，一个记录每个节点的父节点。</p><p>表一（记录所有的节点和其邻居）：</p><table><thead><tr><th align="center">节点</th><th align="center">邻居</th><th align="center">开销</th></tr></thead><tbody><tr><td align="center">start</td><td align="center">A、B</td><td align="center">to A: 6             to B: 2</td></tr><tr><td align="center">A</td><td align="center">fin</td><td align="center">to fin: 1</td></tr><tr><td align="center">B</td><td align="center">A、B</td><td align="center">to A:3              to fin:5</td></tr><tr><td align="center">fin</td><td align="center">None</td><td align="center"></td></tr></tbody></table><p>用代码表示出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 表一，创建用于存储节点的所有邻居的字典</span><br>graph = &#123;&#125;<br>graph[<span class="hljs-string">&quot;start&quot;</span>] = &#123;<span class="hljs-string">&quot;A&quot;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&quot;B&quot;</span>: <span class="hljs-number">2</span>&#125;<br>graph[<span class="hljs-string">&quot;A&quot;</span>] = &#123;<span class="hljs-string">&quot;fin&quot;</span>: <span class="hljs-number">1</span>&#125;<br>graph[<span class="hljs-string">&quot;B&quot;</span>] = &#123;<span class="hljs-string">&quot;A&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&quot;fin&quot;</span>: <span class="hljs-number">5</span>&#125;<br>graph[<span class="hljs-string">&quot;fin&quot;</span>] = &#123;&#125;<br></code></pre></td></tr></table></figure><p>表二（从起点到该节点所需的花销）：</p><table><thead><tr><th align="center">节点</th><th align="center">从起点到该节点所需的开销</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">6</td></tr><tr><td align="center">B</td><td align="center">2</td></tr><tr><td align="center">fin</td><td align="center">infinity</td></tr></tbody></table><p>用代码表示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 由于还不知道到终点需要花费多久，所以用float(&quot;inf&quot;)来代表</span><br>infinity = <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>)<br>costs = &#123;<span class="hljs-string">&quot;A&quot;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&quot;B&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;fin&quot;</span>: infinity&#125;<br></code></pre></td></tr></table></figure><p>表三（节点所对应的父节点）：</p><table><thead><tr><th align="center">节点</th><th align="center">父节点</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">start</td></tr><tr><td align="center">B</td><td align="center">start</td></tr><tr><td align="center">fin</td><td align="center">None</td></tr></tbody></table><p>用代码表示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">parents = &#123;<span class="hljs-string">&quot;A&quot;</span>: <span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>: <span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;fin&quot;</span>: <span class="hljs-literal">None</span>&#125;<br><span class="hljs-comment"># 记录已经处理过的节点</span><br>processed = []<br></code></pre></td></tr></table></figure><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>由于路径还没有开始找，所以我们是不知道花费时间最短的路径是哪一条，我们先给假设最低的时间就是infinity，然后从costs表中找出低于这个时间的节点，再根据这个节点进行路径的查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_lowest_cost_node</span>(<span class="hljs-params">costs</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">这个函数最主要的作用就是检查节点是否已经处理过以及将下一个节点的花销与之前的进行对比，</span><br><span class="hljs-string">如果花销比之前的低，则更新lowest_cost和lowest_cost_node，方便下一次进行比对</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    lowest_cost = <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>)<br>    lowest_cost_node = <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># 遍历记录花费时间的字典</span><br>    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> costs:<br>        <span class="hljs-comment"># 遍历花费时间的字典，取出相应节点所需的时间</span><br>        cost = costs[node]<br>        <span class="hljs-keyword">if</span> cost &lt; lowest_cost <span class="hljs-keyword">and</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> processed:<br>            lowest_cost = cost<br>            lowest_cost_node = node<br>        <span class="hljs-keyword">return</span> lowest_cost_node<br><br><br>node = find_lowest_cost_node(costs)  <span class="hljs-comment"># 初次进行节点的查找</span><br><span class="hljs-keyword">while</span> node <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    cost = costs[node]<br>    neighbors = graph[node]<br>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> neighbors.keys():  <span class="hljs-comment"># 获得节点的所有邻居</span><br>        new_cost = cost + neighbors[n]  <span class="hljs-comment"># 计算从起点到当前节点邻居所需的时间</span><br>        <span class="hljs-comment"># A的邻居是fin，但是从起点到fin的时间未知(也就是infinity)。</span><br>        <span class="hljs-comment"># 所以start to A + A to fin = 7，这个时间会将原本的infinity更新为7</span><br>        <span class="hljs-keyword">if</span> costs[n] &gt; new_cost:<br>            costs[n] = new_cost  <span class="hljs-comment"># 如果经过新节点的时间小于之前所需的时间的话就更新邻居的开销</span><br>            parents[n] = node  <span class="hljs-comment"># 更新该节点的父节点</span><br>    processed.append(node)  <span class="hljs-comment"># 计算过起点到该节点所有邻居的花销后，将其标记为已处理</span><br>    <span class="hljs-built_in">print</span>(node)<br>    node = find_lowest_cost_node(costs)  <span class="hljs-comment"># 再找出下一个节点</span><br><span class="hljs-built_in">print</span>(costs)<br><span class="hljs-built_in">print</span>(parents)<br></code></pre></td></tr></table></figure><h2 id="负权边"><a href="#负权边" class="headerlink" title="负权边"></a>负权边</h2><p><img src="/img/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%B8%83%E7%AB%A0/Snipaste_2020-06-01_17-23-56.png"></p><p>以这张图为例子，0就为最低的开销，检查乐谱的邻居，那么乐谱到海报的开销为0，到黑胶唱片的为5，然后检查开销最小的海报这条路径，到架子鼓开销为35，这样检查完了海报的邻居。接下来就要检查黑胶唱片的邻居海报，但是海报已经检查完了他的邻居，所以已经不能被更新了，但是很明显5+（-7）是要比之前算出来的小的，但被标记过就没有办法更新了，所以这种情况下出现负权边是没有办法找到最小开销的路径的。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广度优先搜索-算法图解第六章</title>
    <link href="/2020/05/13/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <url>/2020/05/13/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在博客里挺多文章都是结合了书上内容来写的，可以说更像是将书上的内容总结出来吧，但是我更想的是按照自己的风格来写，接下来应该会慢慢转变。   </p><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>广度优先搜索可以用来查找最短路径，举个例子：如果你需要找人帮忙，你会先找你身边认识的人，如果你认识的人帮不了你，那么就会找你朋友认识的人，如果还没有找到，就会找你朋友的朋友，直到找到为止。这样你和你的朋友为一度关系，你朋友的朋友就为二度关系，依此类推。对于我们来说，一度关系是比二度关系可靠的，所以检查的时候应该先检查完一度关系后再进行检查二度关系，广度优先搜索也是如此，这样可以找到最短的路径，但前提是要按照顺序去查找。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列就跟其名字一样，排在前面的先进行访问，队列只支持入队和出队，按照顺序来进行读取，不能随机读取。这样的特点和栈相反，栈是后入先出，队列是先入先出(first in first out)。这样可以保证广度优先搜索时按照顺序来进行读取的，顺序的打乱可能会使得找到的路径并不是最短路径。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p>由于是第一次画这个图，所以显得丑了一点，日后练习一下之后再进行修改。</p><p><img src="/img/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E5%85%AD%E7%AB%A0/pkjv.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><span class="hljs-comment"># 创建所需要用到的数据</span><br>graph = &#123;&#125;<br>graph[<span class="hljs-string">&quot;myself&quot;</span>] = [<span class="hljs-string">&quot;nick&quot;</span>, <span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-string">&quot;amy&quot;</span>]<br>graph[<span class="hljs-string">&quot;nick&quot;</span>] = [<span class="hljs-string">&quot;ash&quot;</span>, <span class="hljs-string">&quot;frank&quot;</span>]<br>graph[<span class="hljs-string">&quot;amy&quot;</span>] = [<span class="hljs-string">&quot;mya&quot;</span>, <span class="hljs-string">&quot;kjc&quot;</span>]<br>graph[<span class="hljs-string">&quot;jack&quot;</span>] = [<span class="hljs-string">&quot;akc&quot;</span>, <span class="hljs-string">&quot;kjc&quot;</span>]<br>graph[<span class="hljs-string">&quot;ash&quot;</span>] = []<br>graph[<span class="hljs-string">&quot;frank&quot;</span>] = []<br>graph[<span class="hljs-string">&quot;mya&quot;</span>] = []<br>graph[<span class="hljs-string">&quot;akc&quot;</span>] = []<br>graph[<span class="hljs-string">&quot;kjc&quot;</span>] = []<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">perosn_right</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-comment"># 假设要找的人是kjc</span><br>    <span class="hljs-keyword">return</span> name == <span class="hljs-string">&quot;kc&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">name</span>):</span><br>    search_deque = deque()  <span class="hljs-comment"># 创建一个队列</span><br>    search_deque += graph[name]  <span class="hljs-comment"># 将名字加到队列当中</span><br>    searched = []  <span class="hljs-comment"># 将已经检查过的添加到列表里，避免重复检查</span><br>    <span class="hljs-keyword">while</span> search_deque:  <span class="hljs-comment"># 队列不为空则继续执行</span><br>        person = search_deque.popleft()<br>        <span class="hljs-keyword">if</span> person <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> searched:<br>            <span class="hljs-keyword">if</span> perosn_right(person):<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;the right person is &quot;</span> + person)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <span class="hljs-comment"># 找到之后终止循环</span><br>            <span class="hljs-keyword">else</span>:<br>                search_deque += graph[person]<br>                searched.append(person)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># 执行到这里代表所有人都找完但没有找到</span><br><br><br>search(<span class="hljs-string">&quot;myself&quot;</span>)<br></code></pre></td></tr></table></figure><p>首先先输入了“myself”，然后将myself里面的名字加入队列，这时候队列就包含了(“nick”, “jack”, “amy”)，然后再继续搜索nick，再将nick中的名字添加到队列()，队列就变成(“jack”, “amy”,”ash”, “frank”)，过程就是按照加入队列的顺序来进行搜索。</p><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>deque是在python标准库collections中的一个模块，可以提供一个两端都能操作的队列，队列前后都可以进行增加和删除元素，操作方法和list类似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">deque.appendleft()  <span class="hljs-comment"># 在最左边插入元素</span><br>deque.append()  <span class="hljs-comment"># 在末尾添加元素</span><br>deque.popleft()  <span class="hljs-comment"># 抛出最左边的元素</span><br>deque(maxlen=<span class="hljs-number">20</span>) <span class="hljs-comment"># 限制队列的长度为20</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>散列表-算法图解第五章</title>
    <link href="/2020/05/09/%E6%95%A3%E5%88%97%E8%A1%A8-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <url>/2020/05/09/%E6%95%A3%E5%88%97%E8%A1%A8-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>无论什么数据通过散列函数，它都会返还相对应的数字。但散列函数必须满足以下两个条件：</p><p>​    1.输入相同内容时返回的数字应该是一致的，如果不一致便失去了意义。</p><p>​    2.不同的输入应该对应不同的数字，这样就可以尽量避免与其他冲突。</p><p>假设有三个字符串”aa”, “bb”, “cc”，然后我们创建一个空的数组，通过散列函数的计算后根据散列函数返回的数字来将这三个字符串存在与数字相对应的数组位置中，如果”aa”返回数字3，则将”aa”存放在数组的3位置。查找的时候就可以计算出相应位置，数组的查找速度很快，这样我们便不必耗费较多的时间来进行查找。</p><p>散列表是一种包含额外逻辑的数据结构，数组和链表都是直接映射到内存，而散列表需要通过散列函数来确定元素的位置。散列表的读取速度很快，因为其存储的底层是列表，而python中的散列表就是字典。散列表由键和值组成，键用来确定元素所在的位置，因为其特性，所以字典中键不能相同，如果相同的话就会造成冲突，会将原本已经存储好的元素覆盖。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">dic_1 = &#123;<span class="hljs-string">&quot;jack&quot;</span>:<span class="hljs-number">18</span>, <span class="hljs-string">&quot;mike&quot;</span>:<span class="hljs-number">20</span>,<span class="hljs-string">&quot;nick&quot;</span>:<span class="hljs-number">12</span>&#125;<br><span class="hljs-built_in">print</span>(dic_1[<span class="hljs-string">&quot;jack&quot;</span>])  <span class="hljs-comment"># 通过键来获取年龄</span><br></code></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>1.通讯录中便是名字对应你的电话号码，通过名字来查找电话号码。</p><p>2.平时我们通过域名来访问网站，计算机会将域名转为ip地址。用百度举例，baidu.com，计算机会将其转为14.215.177.39的ip地址后进行访问，这也同样是非常适合用散列表。</p><p>3.散列表中的键是不能重复的，所以我们可以用来防止某些事情或这事物的重复。</p><h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>散列函数根据输入的内容来返回数字，但是不同内容之间同样可能返回相同的数字，当不同内容却返回相同数字的情况称为冲突，这样后面的内容便会覆盖掉之前已经保存的内容，最简单的方法便是在这个位置后面存储一个链表。</p><p><img src="/img/%E6%95%A3%E5%88%97%E8%A1%A8-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%BA%94%E7%AB%A0/2020-05-09-17-43-06.png"></p><p>散列函数最佳的情况便是将键均匀的映射到散列表的不同位置，虽然遇到冲突可以增加链表，但是如果当链表便的很长的时候搜索速度便会下降。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="填装因子"><a href="#填装因子" class="headerlink" title="填装因子"></a>填装因子</h3><p>填装因子计算方法为：散列表包含的元素数/散列表位置/总数一个长度为6的数组中有两个元素，那么它的填装因素便是$\frac26$。最佳的情况是每个元素都有自己的位置，这个时候填装因为就是1，如果位置只有50，而元素有100，那填装因子就是2，所以当填装因子大于0.7的时候将可以将列表的长度进行扩容，降低冲突的情况发生。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序-算法图解第四章</title>
    <link href="/2020/04/22/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    <url>/2020/04/22/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h2><p>divide and conquer(D&amp;C)是一种著名的递归式问题解决方法，快速排序就是一种D&amp;C算法。</p><p>分地问题，一块height:1680m,width:640m的土地，要将其均匀地分成方块，并且分的方块要尽量的大。使用D&amp;C来解决这个问题包括了两个步骤：1.基线条件    2.递归条件 ，每次递归调用都必须缩小问题的规模。</p><p>先划分出两个640*640的土地，然后剩下一个640*400的土地，这时候就简化成了均匀划分640*400土地的问题，实际上这里用的就是欧几里得算法(也称为<a href="%5Bhttps://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fromtitle=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95&fromid=4625352&fr=aladdin%5D(https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fromtitle=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95&fromid=4625352&fr=aladdin)">辗转相除法</a>)，想要求土地的最大均匀分法，求的就是这两个数的最大公约数。</p><p><img src="/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E5%9B%9B%E7%AB%A0/Snipaste_2020-04-16_17-18-37.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">1680*640 ——&gt; 2(640*640) + 640*400<br>640*400  ——&gt; 400*400 + 240*400<br>240*400  ——&gt; 240*240 + 240*160<br>240*160  ——&gt; 160*160 + 160*80<br>160*80   ——&gt; 2*(80*80)<br></code></pre></td></tr></table></figure><p>这样就算出土地可以分的最大方块是80m*80m。</p><p>D&amp;C工作原理：</p><p>​                        1.找出简单的基线条件。</p><p>​                        2.确定如何缩小问题的规模，使其符合极限条件。</p><p><strong>练习1 编写书上sum函数的代码(根据上面那两个步骤来编写)</strong></p><p>这一次书上没有像之前一样把解法写出来，而是把这个作为了习题，但给了很多的提示，下面这一种是我一开始没看答案的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">lst1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum_b</span>(<span class="hljs-params">lst</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lst) == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        temp = lst.pop(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> temp + sum_b(lst)<br><br><span class="hljs-built_in">print</span>(sum_b(lst1))<br></code></pre></td></tr></table></figure><p>这一种是书上的解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">lst1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum_a</span>(<span class="hljs-params">lst</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">list</span> == []:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> lst[<span class="hljs-number">0</span>] + sum_a(lst[<span class="hljs-number">1</span>:])<br><br><span class="hljs-built_in">print</span>(sum_a(lst1))<br></code></pre></td></tr></table></figure><p>看完之后非常想哭，还是有很长的路要走啊。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序需要一个基准值，从数组中选定一个元素作为基准值，将剩下的元素与基准值比对大小，这样就可以将这些元素分为两部分，比基准值小的和比基准值大的。分出来的这两部分很大可能性仍是无序的，所以要再对这两部分的元素递归使用快速排序，这样排好序之后结果是这样的：比基准值小的元素+基准值+比基准值大的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">lst = [<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">30</span>, <span class="hljs-number">50</span>, <span class="hljs-number">15</span>]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quciksort</span>(<span class="hljs-params">lst</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lst) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> lst<br>    <span class="hljs-keyword">else</span>:<br>        refer = lst[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 基准值</span><br>        smaller = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> lst[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> i &lt; refer]  <span class="hljs-comment"># 生成一个包含比基准值小的元素的列表</span><br>        bigger = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> lst[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> i &gt; refer]<br><span class="hljs-comment"># 需要将基准值转为列表才可以相加</span><br>        <span class="hljs-keyword">return</span> quciksort(smaller) + [refer] + quciksort(bigger)<br><br><span class="hljs-built_in">print</span>(quciksort(lst))<br></code></pre></td></tr></table></figure><h3 id="平均情况和最糟情况"><a href="#平均情况和最糟情况" class="headerlink" title="平均情况和最糟情况"></a>平均情况和最糟情况</h3><p>大O表示法表示O(n)实际上指的是这样的：c*n，c是算法所需的固定时间量，即每个元素所需的时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">lst = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p>快速排序的速度依赖于所取的基准值，如果取得基准值总是第一个元素，并且数组本身是有序的，因为没有检查数组是否有序，所以它仍然会对这个有序的进行排序。对一个有序的数组进行排序，在划分成两个数组的时候必定有一边是空的，剩余的元素全在另外一边，调用栈栈长为O(n)</p><p>仍然是一个有序的数组，如果基准值选择中间的，调用栈会短很多，栈长为O($\log_2n$)，每一层需要的时间是O(n)，因此大O表示法为O(n)*O($log_2n$) = O(n $log_2n$)，这个就是快速排序的最佳情况也是平均情况，上面的栈长O(n)则为最糟的情况，运行时间则为O($n^2$)。</p><p>但不是每次都能遇到最佳的情况，所以每次都随机选择一个数组元素来作为基准值，那么快速排序的平均运行时间就为O(n $log_2n$)</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归-算法图解第三章</title>
    <link href="/2020/04/22/%E9%80%92%E5%BD%92-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <url>/2020/04/22/%E9%80%92%E5%BD%92-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归实际上就是自己调用自己，组成递归需要基线条件(告诉程序什么时候停止递归)和递归条件(什么时候开始递归)，如果没有终止程序的条件，程序就会无限循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 递归</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate</span>(<span class="hljs-params">number</span>):</span><br>    <span class="hljs-keyword">if</span> number &lt; <span class="hljs-number">0</span>:<span class="hljs-comment"># 基线条件</span><br>        <span class="hljs-keyword">return</span><span class="hljs-comment"># return可以用来返回和终止</span><br>    <span class="hljs-keyword">else</span>:<span class="hljs-comment"># 递归条件</span><br>        calculate(number - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>例如计算<a href="%5Bhttps://baike.baidu.com/item/%E9%98%B6%E4%B9%98/4437932?fr=aladdin%5D(https://baike.baidu.com/item/%E9%98%B6%E4%B9%98/4437932?fr=aladdin)">5!</a>可以使用循环和递归，使用循环的性能可能会更高，递归则更容易理解。下面写出这两种解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># while循环</span><br>i = <span class="hljs-number">5</span><br>temp = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> i &gt; <span class="hljs-number">1</span>:<br>    temp = i * temp<br>    i -= <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;while循环:&quot;</span> + <span class="hljs-built_in">str</span>(temp))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 递归</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate</span>(<span class="hljs-params">num</span>):</span><br>    <span class="hljs-keyword">if</span> num &lt;= <span class="hljs-number">1</span>:    <span class="hljs-comment"># 1的阶乘是1，同时这个用来结束递归</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> num * calculate(num - <span class="hljs-number">1</span>)<br><br><br><span class="hljs-built_in">print</span>(calculate(<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>假设有一个一叠便条，需要增加内容就写在一张便条上，然后把写好的便条放在最上面，要读取的时候就拿最上面的便条然后删除，因此这就只有两种操作：压入(插入)和弹出(删除并读取)。</p><p>用书里的函数来演示是怎么使用调用栈的：</p><p><img src="/img/%E9%80%92%E5%BD%92-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%B8%89%E7%AB%A0/2020-04-14-12-28-38.png"></p><p>程序从上往下执行，执行greet()函数系统会为其分配一块内存空间，执行到greet2(name)时，greet2()的内存块位于greet()上方，执行完栈顶的内存会被弹出，回到greet()，执行bye()时也同样如此。这个栈用于存储多个函数的变量，被称为调用栈。所有函数调用都会进入调用栈。</p><p>这一章没什么写的，目前对栈的理解还不够全面，日后可能会再修改这一篇文章。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序(算法图解第二章)</title>
    <link href="/2020/04/10/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <url>/2020/04/10/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="数组和列表"><a href="#数组和列表" class="headerlink" title="数组和列表"></a>数组和列表</h2><p>数组和列表各有优劣，数组的元素在内存中的存储是连续的，所以需要分配一定的连续空间，而链表的元素不需要连续存储。</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表可以存储在内存中任何地方，其每个元素都记录了下一个元素的内存地址，所以随机的存放也可以串在一起。这里引入Java中的Node链表，里面的关键是这个几个变量：hash, key, value, next，next记录了下一个节点。</p><p>这样也出现了一个问题，想访问最后一个元素，不能直接进行访问，因为不知道最后一个元素的地址，所以能从头进行访问直到访问到最后一个元素。如果想访问链表中的其中一个元素，其效率是很低的。</p><p><img src="/img/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%BA%8C%E7%AB%A0/lKVZxpJ.png"></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组的存储是连续的，所以想访问其中一个元素，其地址是可以推测出来的，可以迅速找到你想要的元素。Java中的数组会申请一定的空间，当数组满时要添加元素，就会创建一个新的数组，然后把旧的数组的元素移动到新的数组里面，数组的扩容本质上是新创建一个容量更大的数组。</p><h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><p>假设要在元素为0-9的数组和链表的索引4插入一个元素，数组需将索引4开始的元素往后移，链表则只需要修改索引3的元素中指向下一个元素的地址。链表在删除以及插入上都是比数组更好的选择，同样只需修改前一个元素指向的地址即可，数组的删除则需将后面的元素往前移。</p><p>操作时间(只有当能够立即访问要删除的元素时，运行时间才为O(1))：</p><p> <img src="/img/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%BA%8C%E7%AB%A0/3H1js23.png"></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>将列表[9, 8, 7, 6, 1]进行从小到大的排序，可以遍历这个这个列表，找出列表中最小的元素，并将这个元素放进一个新的列表中，直到全部元素都放进了新的列表里面，这样就得到了一个从小到大排序的列表。在对这个列表进行遍历的时候，每个元素都要查看一次，运行时间时O(n)，需要执行n次，则时间为O($n^2$)</p><p>但是随着排序的进行，每次要检查的元素都会减少，并非每次都要检查n个元素，随后要检查的元素为n-1,n-2……平均每次检查的元素数为$\frac 12$，所以运行时间为O(n * $\frac 12$ * n)，但大O表示法省略$\frac 12$这个样的常数，所以简单地写为O($n^2$)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">searchSmallest</span>(<span class="hljs-params">lst</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot; 找出列表中最小的数，并返回其索引 &quot;&quot;&quot;</span><br>    temp = lst[<span class="hljs-number">0</span>]   <span class="hljs-comment"># 先获取列表中第一个数</span><br>    small = <span class="hljs-number">0</span>   <span class="hljs-comment"># 存储最小的元素的索引</span><br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(lst)):<br>        <span class="hljs-keyword">if</span> lst[x] &lt; temp:   <span class="hljs-comment"># 判断temp与列表lst的索引x的值</span><br>            temp = lst[x]<br>            small = x<br>    <span class="hljs-keyword">return</span> small<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selectSort</span>(<span class="hljs-params">lst</span>):</span>    <span class="hljs-comment"># 选择排序</span><br>    newLst = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lst)):<br>        smallest = searchSmallest(lst)<br>        newLst.append(lst.pop(smallest))    <span class="hljs-comment"># pop方法，删除传入的值，并将其返回</span><br>    <span class="hljs-keyword">return</span> newLst<br><br><br>a_list = [<span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(selectSort(a_list))<br><br><span class="hljs-comment"># 结果是：[1, 6, 7, 8, 9]</span><br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>链表的元素是分开的，每个元素都存储了下一个元素的地址。</li><li>数组读取速度很快，但插入和删除的速度很慢，链表则相反。</li><li>同一个数组中，所有元素的类型都必须相同。</li></ul>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python模块总结</title>
    <link href="/2020/03/29/python%E6%A8%A1%E5%9D%97%E6%80%BB%E7%BB%93/"/>
    <url>/2020/03/29/python%E6%A8%A1%E5%9D%97%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>模块的调用及创建</p><h2 id="模块的导入"><a href="#模块的导入" class="headerlink" title="模块的导入"></a>模块的导入</h2><h3 id="模块导入的方式"><a href="#模块导入的方式" class="headerlink" title="模块导入的方式"></a>模块导入的方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<span class="hljs-comment"># 导入一个模块</span><br><span class="hljs-keyword">import</span> math, turtle<span class="hljs-comment"># 这种方式可以导入多个模块</span><br><span class="hljs-keyword">import</span> math <span class="hljs-keyword">as</span> mth<span class="hljs-comment"># 导入模块并赋予新的名字(调用时使用新的名字)</span><br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> pi<span class="hljs-comment"># 导入模块中指定的成员(这样导入后可以直接使用)</span><br>form math <span class="hljs-keyword">import</span> *<span class="hljs-comment"># 导入模块中所有的成员(不建议使用)</span><br><br></code></pre></td></tr></table></figure><h3 id="模块的加载"><a href="#模块的加载" class="headerlink" title="模块的加载"></a>模块的加载</h3><p>导入一个math模块，无论写了多少import语句，都只会加载一次，如果想要重新加载，可以使用这样的方式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> importlib<span class="hljs-comment"># 需要导入这个模块</span><br>importlib.reload(math)<span class="hljs-comment"># 然后调用这个方法</span><br></code></pre></td></tr></table></figure><h2 id="package的使用"><a href="#package的使用" class="headerlink" title="package的使用"></a>package的使用</h2><h3 id="包的结构"><a href="#包的结构" class="headerlink" title="包的结构"></a>包的结构</h3><p>将模块放在一起就形成了“包”，包的文件夹里必须有__init__.py的文件，这个文件就是包的标识，一般用于定义form xxx import * 所导入的成员。<br>包的下面可以有子包，就像文件夹一样，文件夹下可以有文件夹。</p><h3 id="子包的引用"><a href="#子包的引用" class="headerlink" title="子包的引用"></a>子包的引用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">form .. <span class="hljs-keyword">import</span> xx<span class="hljs-comment"># ..表示上级目录</span><br>form . <span class="hljs-keyword">import</span> xx<span class="hljs-comment"># .表示同级目录</span><br></code></pre></td></tr></table></figure><h3 id="sys-path和模块搜索路径"><a href="#sys-path和模块搜索路径" class="headerlink" title="sys.path和模块搜索路径"></a>sys.path和模块搜索路径</h3><p>模块搜索路径(由上到下的顺序进行搜索)：</p><p>​    1.内置模块</p><p>​    2.当前目录</p><p>​    3.程序主目录(也就是项目目录)</p><p>​    4.pythonpath目录(需要设置pythonpath环境变量)</p><p>​    5.标准链接库目录</p><p>​    6.第三方库目录(site-packages)</p><pre><code>7. .pth文件里面的内容(前提是这个文件存在) 8. 通过sys.path.append()临时添加的目录</code></pre><p> 使用sys.path修改搜索目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br>sys.path.append(<span class="hljs-string">&#x27;d:/&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法图解第一章总结</title>
    <link href="/2020/03/27/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2020/03/27/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>最近会抽出点时间慢慢的将这本书看完，希望看完能让自己再进一步。</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>从1-100中猜测一个数字，使用二分查找，每次都猜测的是中间的数字，每一次的猜测，都可以将剩下的数字排除掉一半，比从头猜到尾可以大幅度减少猜测时间。即使要猜测的数字位于尾部，也仍是更佳的查找方式。</p><p><img src="/img/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/9654.png"></p><p>用二分查找最多需要要$log_{2}{n}$次，每一次的查找都会排除掉一半，这里引入<a href="https://baike.baidu.com/item/%E5%AF%B9%E6%95%B0/91326?fr=aladdin">对数</a>的概念(如果a的x次方等于N（a&gt;0，且a不等于1），那么数x叫做以a为底N的对数（logarithm），记作x=$log_{a}{N}$。其中，a叫做对数的<a href="https://baike.baidu.com/item/%E5%BA%95%E6%95%B0/5416651">底数</a>，N叫做<a href="https://baike.baidu.com/item/%E7%9C%9F%E6%95%B0/20402544">真数</a>。)</p><p>​        $10^2$ = 100    –&gt;    $log_{10}{100}$</p><p>​        $10^3$ = 1000    –&gt;    $log_{10}{1000}$</p><p>​        $2^3$ = 8    –&gt;    $log_{2}{8}$</p><p>​        $2^{11}$ = 1024    –&gt;    $log_{2}{1024}$    # 也就意味着，如果列表包含1024个元素，最多需要检查10个元素</p><p>算法图解这本书里使用大O表示法来讨论运行时间，log指的都是$log_{2}{N}$。</p><p>下面用python来编写二分查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search</span>(<span class="hljs-params">a_list, item</span>):</span>  <span class="hljs-comment"># a_list:输入列表 item:假设的数字</span><br>    low = <span class="hljs-number">0</span>  <span class="hljs-comment"># 开头</span><br>    high = <span class="hljs-built_in">len</span>(a_list) - <span class="hljs-number">1</span>  <span class="hljs-comment"># 末尾</span><br>    <span class="hljs-keyword">while</span> low &lt;= high:  <span class="hljs-comment"># 只要不是还剩下一个数就继续运行</span><br>        mid = (low + high) // <span class="hljs-number">2</span>  <span class="hljs-comment"># 计算出中间位置，如果不是整数则向下圆整</span><br>        guess = a_list[mid]<br>        <span class="hljs-keyword">if</span> guess == item:  <span class="hljs-comment"># 取出列表中第mid个与item对比是否相同</span><br>            <span class="hljs-keyword">return</span> mid<br>        <span class="hljs-keyword">elif</span> guess &gt; item:<br>            high = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> guess &lt; item:<br>            low = mid + <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(guess)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><br>a_list = [m <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">128</span>)]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;final:&quot;</span>, binary_search(a_list, <span class="hljs-number">127</span>))<br><br><span class="hljs-comment"># 输出结果</span><br>    <span class="hljs-number">63</span><br>    <span class="hljs-number">95</span><br>    <span class="hljs-number">111</span><br>    <span class="hljs-number">119</span><br>    <span class="hljs-number">123</span><br>    <span class="hljs-number">125</span><br>    <span class="hljs-number">126</span><br>    final: <span class="hljs-number">127</span><br></code></pre></td></tr></table></figure><p>根据上面的代码以及之前的计算公式可以，从0-127共128个有序的数字中进行查找，最多需要7次，也就是$log_{2}{128}$。</p><p>但是那只是我们忽略了一部分，有一个列表[0, 1, 2, 3]共四个数字，我先假设要寻找的数字是4，使用二分查找的方法：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span>--&gt; <span class="hljs-number">1</span> --&gt; <span class="hljs-number">2</span> --&gt; <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>当我们猜测的数字是1时，我们发现就剩下了2和3这个数字，最坏的情况是程序要判断两次后才能找到这个数字，所以我们计算最多查找次数的公式应该为$log_{2}{N}$ + 1 ，上面的$log_{2}{n}$应该代表的是大O表示法。</p><h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h3><p>简单查找逐个检查数字，列表中包含多少个元素，最多就需要检查多少次，这被称为线性时间(linear time)。</p><p>二分查找则快速很多，它的运行时间被成为对数时间(或者 log时间)。</p><p><img src="/img/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/4510.png"></p><h2 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h2><h3 id="如何理解大O表示法"><a href="#如何理解大O表示法" class="headerlink" title="如何理解大O表示法"></a>如何理解大O表示法</h3><p>大O表示法是一种特殊的表示法，用来列出算法的运行时间，但其并非以秒为单位，而是让你能够比较操作数，以及算法运行时间的增速。</p><p>假设检查100个元素，检测一个元素需要一秒，使用简单查找时，必须检查所有元素，而使用二分查找时，只需要查找7个元素，所以7毫秒便可以检测完。</p><p><img src="/img/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/986.png"></p><p>随着元素数量增加，二分查找所需的额外时间不多，但简单查找的却增加了非常多，当列表包含10亿个元素时，二分查找的速度为简单查找的3300万倍。仅仅知道算法运行完毕所需的时间并不够，还需要知道运行时间如何随列表增长而增加，这才是大O表示法的用武之地。</p><p>举个例子，检查长度为n的列表，用大O表示法表示二分查找的运行时间：O($log_{2}{n}$)。</p><p><img src="/img/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/vhjvio.png"></p><h3 id="不同的大O运行时间"><a href="#不同的大O运行时间" class="headerlink" title="不同的大O运行时间"></a>不同的大O运行时间</h3><p>算法一：</p><p>在纸上画格子，画一个格子算作一次操作，需要画16个格子，这个算法运行时间就是O(n)。</p><p>算法二：</p><p>纸对折就是一次操作，第一次对折就相当于花了两个格子，对折四次后便得到了16个格子，每一次的对折，格子数都翻倍了，其运行时间为O($log_{2}{n}$)</p><p>​                                                    2     –&gt;    4    –&gt;    8    –&gt;    16</p><p><strong>大O表示法表示的时最糟的情况，并且要考虑平均情况的运行时间</strong></p><h3 id="常见的大O运行时间"><a href="#常见的大O运行时间" class="headerlink" title="常见的大O运行时间"></a>常见的大O运行时间</h3><ol><li><p>O($log_{2}{n}$) ,也叫对数时间，这样的算法包括二分查找。</p></li><li><p>O(n)，也叫线性时间，这样的包括简单查找。</p></li><li><p>O(n * $log_{2}{n}$)，这样的包括快速排序——一种较快的排序算法。</p></li><li><p>O(n2)，这样包括选择排序——一种速度较慢的排序算法。</p></li><li><p>O(<a href="%5Bhttps://baike.baidu.com/item/%E9%98%B6%E4%B9%98/4437932?fromtitle=n!&fromid=7806135&fr=aladdin%5D(https://baike.baidu.com/item/%E9%98%B6%E4%B9%98/4437932?fromtitle=n!&fromid=7806135&fr=aladdin)">n!</a>)，这样的算法包括的旅行商问题的解决方案——一种非常慢的算法。</p></li></ol><p>下面介绍绘制1024个格子不同算法所需的时间：</p><p><img src="/img/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/wieu.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>算法的速度并非指时间，而是操作数的增速。算法的速度指的是随着输入的增加，其运行速度将以什么样的速度增加。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>__name__ == &#39;__main__&#39;的作用</title>
    <link href="/2020/03/26/python%E5%85%A5%E5%8F%A3%E7%9A%84%E4%B8%80%E4%B8%AA%E7%90%86%E8%A7%A3/"/>
    <url>/2020/03/26/python%E5%85%A5%E5%8F%A3%E7%9A%84%E4%B8%80%E4%B8%AA%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>技术性总结</p><h2 id="name-‘main‘的作用"><a href="#name-‘main‘的作用" class="headerlink" title="name == ‘main‘的作用"></a><strong>name</strong> == ‘<strong>main</strong>‘的作用</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><span id="more"></span><p>这句话d的作用相当于是程序的入口，有点类似于Java中的main方法，直接运行java文件便会执行main方法里面的函数及变量，从其他类进行导入创建实例化对象的时候需要自行调用，main方法里面的内容不会执行，但python中没有统一的入口，都是从脚本第一行开始运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">通常的写法:<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span><br></code></pre></td></tr></table></figure><p>以下面代码为例，如果我们是直接运行某个.py文件(python xxx.py)，下面代码就会执行，如果是当作模块去引用这个文件的话，下面代码并不会执行。引用从别人博客看到的一句话：</p><blockquote><p>通俗的理解__name__ == ‘<strong>main</strong>‘：例如小明.py，在朋友眼中，你是小明(<strong>name</strong> == ‘小明’)；在你自己眼中，你是你自身(<strong>name</strong> == ‘<strong>main</strong>‘)。</p></blockquote><p>先创建一个test1.py，然后直接运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(__name__)  <span class="hljs-comment"># 运行结果：__main__</span><br></code></pre></td></tr></table></figure><p>然后再创建一个test2.py，调用test1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> test1<br><br><span class="hljs-built_in">print</span>(test1.__name__)  <span class="hljs-comment"># 运行结果：test1</span><br></code></pre></td></tr></table></figure><h3 id="计算圆的面积的例子"><a href="#计算圆的面积的例子" class="headerlink" title="计算圆的面积的例子"></a>计算圆的面积的例子</h3><p>先创建一个pi_cal.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">PI = <span class="hljs-number">3.14</span>  <span class="hljs-comment"># 定义一下PI的大小</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printText</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;PI:&quot;</span>, <span class="hljs-number">3.14</span>)<br><br>printText()<br><br><span class="hljs-comment"># 运行结果：PI:3.14</span><br></code></pre></td></tr></table></figure><p>然后我们创建一个area.py用来计算圆的面积，导入pi_cal.py中的PI变量用于计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pi_cai.py <span class="hljs-keyword">import</span> PI    <span class="hljs-comment"># 只导入PI变量</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate</span>(<span class="hljs-params">radius</span>):</span>   <span class="hljs-comment"># 传入半径</span><br>    <span class="hljs-keyword">return</span> PI * (radius ** <span class="hljs-number">2</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;圆的面积：&quot;</span>, calculate(<span class="hljs-number">2</span>))<br><br>main()<br><br><span class="hljs-comment"># 运行结果：PI:3.14   圆的面积:12.56</span><br></code></pre></td></tr></table></figure><p>很明显的，pi_cal.py中的printText()函数也执行了，我们只想要导入PI，并不想执行一次printText()函数，所以我们可以加上 **if <strong>name</strong> == ‘<strong>main</strong>‘，这样子的话就以模块进行导入时便不会执行不想要的函数了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printText</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;PI:&quot;</span>, <span class="hljs-number">3.14</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    printText()<br></code></pre></td></tr></table></figure><p>还看到一种用法觉得很不错：</p><blockquote><p>这个功能还有一个用处：调试代码的时候，在”if <strong>name</strong> == ‘<strong>main</strong>‘“中加入一些我们的调试代码，我们可以让外部模块调用的时候不执行我们的调试代码，但是如果我们想排查问题的时候，直接执行该模块文件，调试代码能够正常运行！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
