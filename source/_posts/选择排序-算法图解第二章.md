---
title: 选择排序(算法图解第二章)
date: 2020-04-10 22:12:52
tags: 
    - algorithm
    - python
categories: #分类(分层)
    - python
index_img: https://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202206/b915b5e9c14f99553e1922c56b17a7e0--1697499871.jpg
---




## 数组和列表

数组和列表各有优劣，数组的元素在内存中的存储是连续的，所以需要分配一定的连续空间，而链表的元素不需要连续存储。



### 链表

链表可以存储在内存中任何地方，其每个元素都记录了下一个元素的内存地址，所以随机的存放也可以串在一起。这里引入Java中的Node链表，里面的关键是这个几个变量：hash, key, value, next，next记录了下一个节点。

这样也出现了一个问题，想访问最后一个元素，不能直接进行访问，因为不知道最后一个元素的地址，所以能从头进行访问直到访问到最后一个元素。如果想访问链表中的其中一个元素，其效率是很低的。

![](/img/选择排序-算法图解第二章/lKVZxpJ.png)



### 数组

数组的存储是连续的，所以想访问其中一个元素，其地址是可以推测出来的，可以迅速找到你想要的元素。Java中的数组会申请一定的空间，当数组满时要添加元素，就会创建一个新的数组，然后把旧的数组的元素移动到新的数组里面，数组的扩容本质上是新创建一个容量更大的数组。



### 插入和删除

假设要在元素为0-9的数组和链表的索引4插入一个元素，数组需将索引4开始的元素往后移，链表则只需要修改索引3的元素中指向下一个元素的地址。链表在删除以及插入上都是比数组更好的选择，同样只需修改前一个元素指向的地址即可，数组的删除则需将后面的元素往前移。

操作时间(只有当能够立即访问要删除的元素时，运行时间才为O(1))：

 ![](/img/选择排序-算法图解第二章/3H1js23.png)






## 选择排序

将列表[9, 8, 7, 6, 1]进行从小到大的排序，可以遍历这个这个列表，找出列表中最小的元素，并将这个元素放进一个新的列表中，直到全部元素都放进了新的列表里面，这样就得到了一个从小到大排序的列表。在对这个列表进行遍历的时候，每个元素都要查看一次，运行时间时O(n)，需要执行n次，则时间为O($n^2$)

但是随着排序的进行，每次要检查的元素都会减少，并非每次都要检查n个元素，随后要检查的元素为n-1,n-2......平均每次检查的元素数为$\frac 12$，所以运行时间为O(n * $\frac 12$ * n)，但大O表示法省略$\frac 12$这个样的常数，所以简单地写为O($n^2$)

```python
    def searchSmallest(lst):
        """ 找出列表中最小的数，并返回其索引 """
        temp = lst[0]   # 先获取列表中第一个数
        small = 0   # 存储最小的元素的索引
        for x in range(1, len(lst)):
            if lst[x] < temp:   # 判断temp与列表lst的索引x的值
                temp = lst[x]
                small = x
        return small


    def selectSort(lst):    # 选择排序
        newLst = []
        for i in range(len(lst)):
            smallest = searchSmallest(lst)
            newLst.append(lst.pop(smallest))    # pop方法，删除传入的值，并将其返回
        return newLst


    a_list = [9, 8, 7, 6, 1]
    print(selectSort(a_list))
    
   	# 结果是：[1, 6, 7, 8, 9]
```





## 小结

* 链表的元素是分开的，每个元素都存储了下一个元素的地址。
* 数组读取速度很快，但插入和删除的速度很慢，链表则相反。
* 同一个数组中，所有元素的类型都必须相同。