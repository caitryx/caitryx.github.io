---
title: 快速排序-算法图解第四章
date: 2020-04-22 19:01:37
tags: [python,algorithm]
categories: #分类(分层)
    - python
index_img: https://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202112/e6911c2f31d50d15e930072ae3bb186c--3926264918.jpg
---


## 分而治之

divide and conquer(D&C)是一种著名的递归式问题解决方法，快速排序就是一种D&C算法。

分地问题，一块height:1680m,width:640m的土地，要将其均匀地分成方块，并且分的方块要尽量的大。使用D&C来解决这个问题包括了两个步骤：1.基线条件	2.递归条件 ，每次递归调用都必须缩小问题的规模。

先划分出两个640\*640的土地，然后剩下一个640\*400的土地，这时候就简化成了均匀划分640\*400土地的问题，实际上这里用的就是欧几里得算法(也称为[辗转相除法]([https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fromtitle=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95&fromid=4625352&fr=aladdin](https://baike.baidu.com/item/欧几里得算法/1647675?fromtitle=辗转相除法&fromid=4625352&fr=aladdin)))，想要求土地的最大均匀分法，求的就是这两个数的最大公约数。

![](/img/快速排序-算法图解第四章/Snipaste_2020-04-16_17-18-37.png)


```bash
1680*640 ——> 2(640*640) + 640*400
640*400  ——> 400*400 + 240*400
240*400  ——> 240*240 + 240*160
240*160  ——> 160*160 + 160*80
160*80   ——> 2*(80*80)
```

这样就算出土地可以分的最大方块是80m\*80m。

D&C工作原理：

​						1.找出简单的基线条件。

​						2.确定如何缩小问题的规模，使其符合极限条件。



**练习1 编写书上sum函数的代码(根据上面那两个步骤来编写)**

这一次书上没有像之前一样把解法写出来，而是把这个作为了习题，但给了很多的提示，下面这一种是我一开始没看答案的写法：

```python
lst1 = [1, 2, 3, 4, 5]

def sum_b(lst):
    if len(lst) == 0:
        return 0
    else:
        temp = lst.pop(0)
        return temp + sum_b(lst)

print(sum_b(lst1))
```

这一种是书上的解法：

```python 
lst1 = [1, 2, 3, 4, 5]

def sum_a(lst):
    if list == []:
        return 0
    return lst[0] + sum_a(lst[1:])

print(sum_a(lst1))
```

看完之后非常想哭，还是有很长的路要走啊。





## 快速排序

快速排序需要一个基准值，从数组中选定一个元素作为基准值，将剩下的元素与基准值比对大小，这样就可以将这些元素分为两部分，比基准值小的和比基准值大的。分出来的这两部分很大可能性仍是无序的，所以要再对这两部分的元素递归使用快速排序，这样排好序之后结果是这样的：比基准值小的元素+基准值+比基准值大的元素。

```python
lst = [10, 5, 3, 4, 30, 50, 15]

def quciksort(lst):
    if len(lst) <= 1:
        return lst
    else:
        refer = lst[0]  # 基准值
        smaller = [i for i in lst[1:] if i < refer]  # 生成一个包含比基准值小的元素的列表
        bigger = [i for i in lst[1:] if i > refer]
		# 需要将基准值转为列表才可以相加
        return quciksort(smaller) + [refer] + quciksort(bigger)

print(quciksort(lst))
```



### 平均情况和最糟情况

大O表示法表示O(n)实际上指的是这样的：c*n，c是算法所需的固定时间量，即每个元素所需的时间。

```python
lst = [1, 2, 3, 4, 5, 6, 7, 8]
```



快速排序的速度依赖于所取的基准值，如果取得基准值总是第一个元素，并且数组本身是有序的，因为没有检查数组是否有序，所以它仍然会对这个有序的进行排序。对一个有序的数组进行排序，在划分成两个数组的时候必定有一边是空的，剩余的元素全在另外一边，调用栈栈长为O(n)

仍然是一个有序的数组，如果基准值选择中间的，调用栈会短很多，栈长为O($\log_2n$)，每一层需要的时间是O(n)，因此大O表示法为O(n)*O($log_2n$) = O(n $log_2n$)，这个就是快速排序的最佳情况也是平均情况，上面的栈长O(n)则为最糟的情况，运行时间则为O($n^2$)。

但不是每次都能遇到最佳的情况，所以每次都随机选择一个数组元素来作为基准值，那么快速排序的平均运行时间就为O(n $log_2n$)