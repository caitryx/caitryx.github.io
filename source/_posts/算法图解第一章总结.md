---
title: 算法图解第一章总结
date: 2020-03-27 20:32:45
tags: [python]
categories: #分类(分层)
    - python
index_img: https://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202206/68f86d362df501423bf9ff7e1c2876f2--2215860932.jpg
---

最近会抽出点时间慢慢的将这本书看完，希望看完能让自己再进一步。


##  二分查找

### 解释

从1-100中猜测一个数字，使用二分查找，每次都猜测的是中间的数字，每一次的猜测，都可以将剩下的数字排除掉一半，比从头猜到尾可以大幅度减少猜测时间。即使要猜测的数字位于尾部，也仍是更佳的查找方式。


![](/img/算法图解第一章总结/9654.png)


用二分查找最多需要要$log_{2}{n}$次，每一次的查找都会排除掉一半，这里引入[对数](https://baike.baidu.com/item/对数/91326?fr=aladdin)的概念(如果a的x次方等于N（a>0，且a不等于1），那么数x叫做以a为底N的对数（logarithm），记作x=$log_{a}{N}$。其中，a叫做对数的[底数](https://baike.baidu.com/item/底数/5416651)，N叫做[真数](https://baike.baidu.com/item/真数/20402544)。)

​		$10^2$ = 100	-->	$log_{10}{100}$

​		$10^3$ = 1000	-->	$log_{10}{1000}$

​		$2^3$ = 8	-->	$log_{2}{8}$

​		$2^{11}$ = 1024	-->	$log_{2}{1024}$	# 也就意味着，如果列表包含1024个元素，最多需要检查10个元素



算法图解这本书里使用大O表示法来讨论运行时间，log指的都是$log_{2}{N}$。

下面用python来编写二分查找

```python
    def binary_search(a_list, item):  # a_list:输入列表 item:假设的数字
        low = 0  # 开头
        high = len(a_list) - 1  # 末尾
        while low <= high:  # 只要不是还剩下一个数就继续运行
            mid = (low + high) // 2  # 计算出中间位置，如果不是整数则向下圆整
            guess = a_list[mid]
            if guess == item:  # 取出列表中第mid个与item对比是否相同
                return mid
            elif guess > item:
                high = mid - 1
            elif guess < item:
                low = mid + 1
            print(guess)
        return None


    a_list = [m for m in range(128)]
    print("final:", binary_search(a_list, 127))
    
    # 输出结果
        63
        95
        111
        119
        123
        125
        126
        final: 127
```

根据上面的代码以及之前的计算公式可以，从0-127共128个有序的数字中进行查找，最多需要7次，也就是$log_{2}{128}$。

但是那只是我们忽略了一部分，有一个列表[0, 1, 2, 3]共四个数字，我先假设要寻找的数字是4，使用二分查找的方法：

```
	3 --> 1 --> 2 --> 3
```

当我们猜测的数字是1时，我们发现就剩下了2和3这个数字，最坏的情况是程序要判断两次后才能找到这个数字，所以我们计算最多查找次数的公式应该为$log_{2}{N}$ + 1 ，上面的$log_{2}{n}$应该代表的是大O表示法。



### 运行时间

简单查找逐个检查数字，列表中包含多少个元素，最多就需要检查多少次，这被称为线性时间(linear time)。

二分查找则快速很多，它的运行时间被成为对数时间(或者 log时间)。

![](/img/算法图解第一章总结/4510.png)






## 大O表示法

### 如何理解大O表示法

大O表示法是一种特殊的表示法，用来列出算法的运行时间，但其并非以秒为单位，而是让你能够比较操作数，以及算法运行时间的增速。

假设检查100个元素，检测一个元素需要一秒，使用简单查找时，必须检查所有元素，而使用二分查找时，只需要查找7个元素，所以7毫秒便可以检测完。

![](/img/算法图解第一章总结/986.png)


随着元素数量增加，二分查找所需的额外时间不多，但简单查找的却增加了非常多，当列表包含10亿个元素时，二分查找的速度为简单查找的3300万倍。仅仅知道算法运行完毕所需的时间并不够，还需要知道运行时间如何随列表增长而增加，这才是大O表示法的用武之地。

举个例子，检查长度为n的列表，用大O表示法表示二分查找的运行时间：O($log_{2}{n}$)。

![](/img/算法图解第一章总结/vhjvio.png)




### 不同的大O运行时间

算法一：

在纸上画格子，画一个格子算作一次操作，需要画16个格子，这个算法运行时间就是O(n)。

算法二：

纸对折就是一次操作，第一次对折就相当于花了两个格子，对折四次后便得到了16个格子，每一次的对折，格子数都翻倍了，其运行时间为O($log_{2}{n}$)

​													2 	-->	4	-->	8	-->	16

**大O表示法表示的时最糟的情况，并且要考虑平均情况的运行时间**



### 常见的大O运行时间

1. O($log_{2}{n}$) ,也叫对数时间，这样的算法包括二分查找。

2. O(n)，也叫线性时间，这样的包括简单查找。

3. O(n * $log_{2}{n}$)，这样的包括快速排序——一种较快的排序算法。

4. O(n2)，这样包括选择排序——一种速度较慢的排序算法。

5. O([n!]([https://baike.baidu.com/item/%E9%98%B6%E4%B9%98/4437932?fromtitle=n%21&fromid=7806135&fr=aladdin](https://baike.baidu.com/item/阶乘/4437932?fromtitle=n!&fromid=7806135&fr=aladdin)))，这样的算法包括的旅行商问题的解决方案——一种非常慢的算法。

下面介绍绘制1024个格子不同算法所需的时间：

![](/img/算法图解第一章总结/wieu.png)




## 总结

算法的速度并非指时间，而是操作数的增速。算法的速度指的是随着输入的增加，其运行速度将以什么样的速度增加。